function Complete-CueFromEditedFile {
    <#
    .SYNOPSIS
      Create a well-formed .cue from an edited cue that contains FILE entries.

    .PARAMETER CuePath
      Path to the edited cue file (must be writable).

    .PARAMETER Overwrite
      Overwrite the target cue file (default: create backup and overwrite).

    .PARAMETER BackupSuffix
      Suffix format for backup; default uses timestamp.

    .DESCRIPTION
      Reads the cue at $CuePath and looks for FILE lines. If multiple FILE lines
      are present it will generate TRACK entries (one TRACK per FILE) with
      INDEX 01 00:00:00 and minimal TITLE/PERFORMER placeholders. If the cue
      already contains TRACK lines, the function refuses to run unless
      -Overwrite is supplied (to avoid clobbering real work).
    #>
    param(
        [Parameter(Mandatory = $true)][string]$CuePath,
        [switch]$Overwrite,
        [string]$BackupSuffix = (Get-Date -Format 'yyyyMMddHHmmss')
    )

    if (-not (Test-Path -LiteralPath $CuePath)) {
        throw "Cue file not found: $CuePath"
    }

    $raw = Get-Content -LiteralPath $CuePath -ErrorAction Stop | ForEach-Object { ($_ -as [string]).TrimEnd() }

    # Regexes
    $fileRegex = [regex]'(?i)^\s*FILE\s+"?([^"]+)"?\s+(\w+)?'
    $trackRegex = [regex]'(?i)^\s*TRACK\s+\d+\s+'
    $titleRegex = [regex]'(?i)^\s*TITLE\s+"?(.+?)"?\s*$'
    $performerRegex = [regex]'(?i)^\s*PERFORMER\s+"?(.+?)"?\s*$'

    # If TRACK lines exist, don't auto-complete unless user explicitly allowed Overwrite:
    if ($raw | Where-Object { $_ -match $trackRegex }) {
        if (-not $Overwrite.IsPresent) {
            throw "Cue already contains TRACK entries. Run with -Overwrite to force rewrite."
        }
    }

    # Collect top-level TITLE/PERFORMER (first occurrences)
    $topTitle = $null; $topPerformer = $null
    foreach ($l in $raw) {
        if (-not $topPerformer) {
            $m = $performerRegex.Match($l)
            if ($m.Success) { $topPerformer = $m.Groups[1].Value; if ($topTitle) { break } }
        }
        if (-not $topTitle) {
            $m = $titleRegex.Match($l)
            if ($m.Success) { $topTitle = $m.Groups[1].Value; if ($topPerformer) { break } }
        }
    }

    # Find FILE entries in order
    $fileEntries = @()
    foreach ($l in $raw) {
        $m = $fileRegex.Match($l)
        if ($m.Success) {
            $fname = $m.Groups[1].Value.Trim()
            $fmt = if ($m.Groups[2].Value) { $m.Groups[2].Value } else { '' }
            $fileEntries += [PSCustomObject]@{ Name = $fname; Format = $fmt }
        }
    }

    if (-not $fileEntries -or $fileEntries.Count -eq 0) {
        throw "No FILE entries found in $CuePath - nothing to finalize."
    }

    # If there's only one FILE entry, warn and require confirmation (user may want to split indexes manually)
    if ($fileEntries.Count -eq 1 -and -not $Overwrite.IsPresent) {
        # We allow single-file finalization but ask user to confirm elsewhere (UI handles prompt).
        # Here we proceed but record that user confirmed via caller by using -Overwrite or UI flow.
        # We'll still create a single TRACK entry.
    }

    # Build final cue content: preserve top-level PERFORMER/TITLE if present, otherwise placeholders
    $out = New-Object System.Collections.Generic.List[string]
    #$out.Add('; Generated by CueFixer Complete-CueFromEditedFile')
    if ($topPerformer) { $out.Add('PERFORMER "{0}"' -f $topPerformer) } else { $out.Add('PERFORMER ""') }
    if ($topTitle)     { $out.Add('TITLE "{0}"' -f $topTitle) }     else { $out.Add('TITLE ""') }

    # Add tracks: one TRACK per FILE
    $trackNum = 1
    foreach ($fe in $fileEntries) {
        $fname = $fe.Name
        $format = $fe.Format
        if ([string]::IsNullOrEmpty($format)) {
            # choose common default by extension: WAVE for wav, else BINARY
            $ext = [System.IO.Path]::GetExtension($fname).TrimStart('.').ToLowerInvariant()
            $format = if ($ext -eq 'wav') { 'WAVE' } else { 'BINARY' }
        }
        $out.Add(('FILE "{0}" {1}' -f $fname, $format))
        $tn = "{0:00}" -f $trackNum
        $out.Add(('  TRACK {0} AUDIO' -f $tn))
        # Track title from file base name
        $base = [System.IO.Path]::GetFileNameWithoutExtension($fname)
        $out.Add(('    TITLE "{0}"' -f $base))
        $out.Add('    PERFORMER ""')
        $out.Add('    INDEX 01 00:00:00')
        $trackNum++
    }

    # Write backup
    $backupPath = "$CuePath.precomplete.$BackupSuffix.bak"
    try {
        Copy-Item -LiteralPath $CuePath -Destination $backupPath -Force -ErrorAction Stop
    }
    catch {
        throw "Failed to write backup $backupPath : $($_.Exception.Message)"
    }

    # Overwrite original
    try {
        $out | Set-Content -LiteralPath $CuePath -Encoding utf8
    }
    catch {
        throw "Failed to write finalized cue: $($_.Exception.Message)"
    }

    return [PSCustomObject]@{ CuePath = (Resolve-Path $CuePath).Path; Backup = $backupPath; Tracks = $trackNum - 1 }
}

Export-ModuleMember -Function Complete-CueFromEditedFile -ErrorAction SilentlyContinue